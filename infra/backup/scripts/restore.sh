#!/bin/bash
# ============================================================
# Point-in-Time Restore Script
# 
# Restores a database to a specific point in time using:
# 1. Daily base backup
# 2. WAL files replayed up to target time
# ============================================================

set -e

# Arguments
DB_NAME="${1:-order-db}"
TARGET_TIME="${2:-$(date '+%Y-%m-%d %H:%M:%S')}"
RESTORE_DIR="${3:-/restore/${DB_NAME}}"

# Configuration
BACKUP_BASE_DIR="/backup/base"
WAL_DIR="/backup/wal"
BUNDLE_DIR="/backup/bundles"
LOG_FILE="/backup/logs/restore.log"

TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
TARGET_DATE=$(echo "${TARGET_TIME}" | cut -d' ' -f1)

log() {
    echo "[${TIMESTAMP}] $1" | tee -a "${LOG_FILE}"
}

mkdir -p "$(dirname ${LOG_FILE})"

log "=========================================="
log "Starting Point-in-Time Recovery"
log "Database: ${DB_NAME}"
log "Target Time: ${TARGET_TIME}"
log "=========================================="

# Step 1: Find the most recent base backup before target time
BASE_BACKUP_DIR="${BACKUP_BASE_DIR}/${DB_NAME}"
AVAILABLE_BACKUPS=$(ls -1 "${BASE_BACKUP_DIR}" 2>/dev/null | sort -r)

SELECTED_BACKUP=""
for BACKUP_DATE in ${AVAILABLE_BACKUPS}; do
    if [[ "${BACKUP_DATE}" <= "${TARGET_DATE}" ]]; then
        SELECTED_BACKUP="${BACKUP_DATE}"
        break
    fi
done

if [ -z "${SELECTED_BACKUP}" ]; then
    log "ERROR: No base backup found before ${TARGET_TIME}"
    log "Available backups: ${AVAILABLE_BACKUPS}"
    exit 1
fi

log "Using base backup from: ${SELECTED_BACKUP}"

# Step 2: Prepare restore directory
log "Preparing restore directory: ${RESTORE_DIR}"
rm -rf "${RESTORE_DIR}"
mkdir -p "${RESTORE_DIR}"

# Extract base backup
BASE_BACKUP_PATH="${BASE_BACKUP_DIR}/${SELECTED_BACKUP}"
if [ -f "${BASE_BACKUP_PATH}/base.tar.gz" ]; then
    tar -xzf "${BASE_BACKUP_PATH}/base.tar.gz" -C "${RESTORE_DIR}"
elif [ -f "${BASE_BACKUP_PATH}/base.tar" ]; then
    tar -xf "${BASE_BACKUP_PATH}/base.tar" -C "${RESTORE_DIR}"
else
    # Copy directory contents
    cp -r "${BASE_BACKUP_PATH}"/* "${RESTORE_DIR}/" 2>/dev/null || true
fi

log "Base backup extracted"

# Step 3: Setup WAL recovery
WAL_RESTORE_DIR="${RESTORE_DIR}/pg_wal"
mkdir -p "${WAL_RESTORE_DIR}"

# Copy WAL files from archive
if [ -d "${WAL_DIR}/${DB_NAME}" ]; then
    for WAL_FILE in "${WAL_DIR}/${DB_NAME}"/*.gz; do
        if [ -f "${WAL_FILE}" ]; then
            gunzip -c "${WAL_FILE}" > "${WAL_RESTORE_DIR}/$(basename ${WAL_FILE} .gz)"
        fi
    done
    log "WAL files copied from archive"
fi

# Extract WAL bundles between base backup date and target date
TARGET_HOUR=$(echo "${TARGET_TIME}" | cut -d' ' -f2 | cut -d':' -f1)
for BUNDLE in "${BUNDLE_DIR}/${DB_NAME}"/*.tar.gz; do
    if [ -f "${BUNDLE}" ]; then
        BUNDLE_NAME=$(basename "${BUNDLE}" .tar.gz)
        BUNDLE_DATE=$(echo "${BUNDLE_NAME}" | cut -d'-' -f1-3)
        BUNDLE_HOUR=$(echo "${BUNDLE_NAME}" | cut -d'-' -f4)
        
        # Include bundles from backup date until target time
        if [[ "${BUNDLE_DATE}" >= "${SELECTED_BACKUP}" ]] && [[ "${BUNDLE_DATE}" <= "${TARGET_DATE}" ]]; then
            if [[ "${BUNDLE_DATE}" < "${TARGET_DATE}" ]] || [[ "${BUNDLE_HOUR}" <= "${TARGET_HOUR}" ]]; then
                tar -xzf "${BUNDLE}" -C "${WAL_RESTORE_DIR}" 2>/dev/null || true
                log "Applied WAL bundle: ${BUNDLE_NAME}"
            fi
        fi
    fi
done

# Step 4: Create recovery configuration
RECOVERY_CONF="${RESTORE_DIR}/postgresql.auto.conf"
cat >> "${RECOVERY_CONF}" <<EOF

# Point-in-Time Recovery Configuration
# Generated by restore.sh at ${TIMESTAMP}
restore_command = 'cp ${WAL_RESTORE_DIR}/%f %p || true'
recovery_target_time = '${TARGET_TIME}'
recovery_target_action = 'promote'
EOF

# Create recovery signal file (PostgreSQL 12+)
touch "${RESTORE_DIR}/recovery.signal"

log "Recovery configuration created"

# Step 5: Output instructions
log "=========================================="
log "RESTORE PREPARATION COMPLETE"
log "=========================================="
log ""
log "To complete the restore:"
log ""
log "1. Stop the current database container:"
log "   docker-compose stop ${DB_NAME}"
log ""
log "2. Replace the data directory:"
log "   docker cp ${RESTORE_DIR} ${DB_NAME}:/var/lib/postgresql/data"
log ""
log "3. Start the database:"
log "   docker-compose start ${DB_NAME}"
log ""
log "4. PostgreSQL will replay WAL and recover to: ${TARGET_TIME}"
log ""
log "=========================================="

# Create restore script for convenience
RESTORE_SCRIPT="${RESTORE_DIR}/apply-restore.sh"
cat > "${RESTORE_SCRIPT}" <<EOF
#!/bin/bash
# Auto-generated restore script
# Target: ${DB_NAME} -> ${TARGET_TIME}

echo "Stopping ${DB_NAME}..."
docker-compose stop ${DB_NAME}

echo "Copying restored data..."
docker cp ${RESTORE_DIR}/. ${DB_NAME}:/var/lib/postgresql/data/

echo "Starting ${DB_NAME}..."
docker-compose start ${DB_NAME}

echo "Waiting for recovery..."
sleep 10

echo "Checking database status..."
docker-compose exec ${DB_NAME} pg_isready

echo "Restore complete!"
EOF
chmod +x "${RESTORE_SCRIPT}"

log "Restore script created: ${RESTORE_SCRIPT}"
log "Run it to apply the restore automatically"
